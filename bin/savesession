#!/bin/bash

# savesession - AFS FastAPI Session State Snapshot with Compaction
# Universal command for saving complete project state (conceptual, contextual, functional)
#
# CRITICAL REQUIREMENT: Session state MUST be compacted before any changes applied
# This ensures session knowledge remains accessible and manageable across all sessions

set -e

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${BLUE}üíæ AFS FastAPI Session State Snapshot with Compaction${NC}"
echo -e "${BLUE}=====================================================${NC}"
echo

# Determine project root relative to this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Session state file locations
CURRENT_DATE=$(date +%Y_%m_%d)
SESSION_STATE_FILE="${PROJECT_ROOT}/docs/monitoring/SESSION_STATE_${CURRENT_DATE}.md"
SESSION_SUMMARY_ROOT="${PROJECT_ROOT}/SESSION_SUMMARY.md"
SESSION_SUMMARY_DOCS="${PROJECT_ROOT}/docs/monitoring/SESSION_SUMMARY.md"

echo -e "${YELLOW}üìã CRITICAL: Session State Compaction Protocol${NC}"
echo -e "${YELLOW}================================================${NC}"
echo "Session state MUST be compacted before applying changes."
echo "This ensures knowledge remains accessible across all sessions."
echo

# Check if compaction has been performed
echo -e "${BLUE}üîç Verifying session state compaction...${NC}"

if [ -f "${SESSION_STATE_FILE}" ]; then
    echo -e "${RED}‚ö†Ô∏è  WARNING: Session state file already exists for today${NC}"
    echo "   File: ${SESSION_STATE_FILE}"
    echo
    echo -e "${YELLOW}This may indicate:${NC}"
    echo "   1. Session state already saved today (compaction complete)"
    echo "   2. Multiple sessions on same day (review existing state)"
    echo "   3. Need to compact into SESSION_SUMMARY.md before proceeding"
    echo
    read -p "Continue and overwrite existing state? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}‚ùå Session save cancelled${NC}"
        exit 1
    fi
fi

echo -e "${GREEN}‚úÖ Proceeding with session state snapshot${NC}"
echo

# Gather current project state
echo -e "${BLUE}üìä Gathering Current Project State...${NC}"
echo

# Get git information
CURRENT_BRANCH=$(git branch --show-current)
GIT_STATUS=$(git status --porcelain)
COMMITS_AHEAD=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
RECENT_COMMITS=$(git log --oneline -5)

# Get test count without hard-coded fallback
if TESTS_RAW=$(pytest --collect-only -q 2>/dev/null | tail -1); then
    TEST_COUNT=$(echo "$TESTS_RAW" | grep -oE '[0-9]+ tests?')
else
    TEST_COUNT="unknown tests"
fi

# Get platform version from SESSION_SUMMARY.md (try root first, then docs fallback)
if [ -f "${SESSION_SUMMARY_ROOT}" ]; then
    PLATFORM_VERSION=$(grep -m 1 "Version.*v0\." "${SESSION_SUMMARY_ROOT}" | grep -oE "v[0-9]+\.[0-9]+\.[0-9]+\+?" || echo "v0.1.3+")
elif [ -f "${SESSION_SUMMARY_DOCS}" ]; then
    PLATFORM_VERSION=$(grep -m 1 "Version.*v0\." "${SESSION_SUMMARY_DOCS}" | grep -oE "v[0-9]+\.[0-9]+\.[0-9]+\+?" || echo "v0.1.3+")
else
    PLATFORM_VERSION="v0.1.3+"
fi

echo "   ‚Ä¢ Branch: ${CURRENT_BRANCH}"
echo "   ‚Ä¢ Version: ${PLATFORM_VERSION}"
echo "   ‚Ä¢ Tests: ${TEST_COUNT}"
echo "   ‚Ä¢ Commits ahead: ${COMMITS_AHEAD}"
echo

# Create session state snapshot
echo -e "${BLUE}üìù Creating Session State Snapshot...${NC}"
echo

cat > "${SESSION_STATE_FILE}" << 'SNAPSHOT_EOF'
# Session State Snapshot - $(date +%Y-%m-%d)

> **Session Date**: $(date +%Y-%m-%d)
> **Platform Version**: PLATFORM_VERSION_PLACEHOLDER
> **Branch**: BRANCH_PLACEHOLDER
> **Session Type**: COMPACTED - Ready for new session
> **Created By**: savesession command

---

## CRITICAL: Session State Compaction

**‚ö†Ô∏è  MANDATORY BEFORE CHANGES**: This session state snapshot was created with the understanding that session state MUST be compacted before applying any changes.

**Compaction Protocol**:
1. **Review this snapshot**: Understand current conceptual, contextual, and functional state
2. **Compact into SESSION_SUMMARY.md**: Move critical achievements to permanent record
3. **Archive old state**: Previous session state files can be archived or removed
4. **Begin new work**: Only after compaction is complete

**Rationale**: Session state snapshots capture point-in-time state with full detail. Without compaction, knowledge becomes fragmented across multiple snapshot files, making it difficult for future sessions (human or AI) to understand platform evolution. Compaction ensures SESSION_SUMMARY.md remains the authoritative, accessible source of truth.

---

## Conceptual State (What to do)

### Mandatory Requirements for ALL AI Agents

**Current Enforcement Status**: All requirements operational with universal AI agent support

MANDATORY_REQUIREMENTS_PLACEHOLDER

**Universal AI Agent Support**:
- Claude Code (Anthropic) - Primary development assistant
- GitHub Copilot (Microsoft/OpenAI) - Pair programming assistant
- ChatGPT Code Interpreter (OpenAI) - Conversational coding
- Gemini Code Assist (Google) - AI-powered development
- Amazon CodeWhisperer (AWS) - ML code generation
- Any Future AI Agent - Requirements apply universally

---

## Contextual State (Current status)

### Platform Metrics

**Version**: PLATFORM_VERSION_PLACEHOLDER
**Test Count**: TEST_COUNT_PLACEHOLDER
**Branch**: BRANCH_PLACEHOLDER (COMMITS_AHEAD_PLACEHOLDER commits ahead)
**Working Directory**: WORKING_DIR_STATUS_PLACEHOLDER

**Code Quality**: QUALITY_STATUS_PLACEHOLDER

**Industry Compliance**:
- ISO 11783 (ISOBUS): Complete implementation
- ISO 18497 (Safety): Complete implementation

**Distributed Systems**:
- Vector Clock: Operational
- CRDT Foundation: Ready for implementation

### Recent Session Activity

RECENT_ACTIVITY_PLACEHOLDER

---

## Functional State (How it works)

### Session Initialization Architecture

**Complete Documentation**: [docs/EXECUTION_ORDER.md](../EXECUTION_ORDER.md)

**6-Phase Architecture**:
1. Automatic Hook-Based Initialization
2. Manual Session Loading (bin/loadsession)
3. Conceptual Context Loading
4. Enforcement & Validation
5. Mandatory Requirement References
6. Helper Commands & Utilities

**Key Files**: 28+ files working together for session establishment

### Enforcement Mechanisms

**Pre-Commit Hooks** (7 total):
1. Ruff (lint)
2. Black (format check)
3. isort (imports check)
4. MyPy (type check)
5. TDD Enforcement
6. Safety Standards Validation
7. CHANGELOG.md Enforcement

**Claude Code Hooks** (3 types):
1. SessionStart: session_initialization.py
2. PreToolUse: session_initialization.py, pre_tool_validation_wrapper.py
3. UserPromptSubmit: user_prompt_tdd_wrapper.py

---

## Git State

### Branch Status
- **Current Branch**: BRANCH_PLACEHOLDER
- **Status**: COMMITS_AHEAD_PLACEHOLDER commits ahead of origin
- **Working Directory**: WORKING_DIR_STATUS_PLACEHOLDER

### Recent Commits
RECENT_COMMITS_PLACEHOLDER

---

## Next Session Actions

### CRITICAL FIRST STEP: Compact This State

**Before starting new work**:
1. Review this snapshot completely
2. Identify critical achievements to preserve
3. Update SESSION_SUMMARY.md with compacted knowledge
4. Archive or remove old session state snapshots
5. Verify SESSION_SUMMARY.md reflects current platform state

### Strategic Priorities

STRATEGIC_PRIORITIES_PLACEHOLDER

---

## Agricultural Robotics Impact

### Safety-Critical System Benefits

**ISO Compliance**:
- Complete decision auditing across all AI platforms
- Verifiable reasoning for multi-tractor coordination code
- Traceable change management for safety audits

**Equipment Operator Confidence**:
- Uniform code quality regardless of AI tool used
- Consistent testing standards across all generation methods
- Bulletproof reliability through Test-First Development

### Universal AI Agent Value

**Team Scaling**:
- Developers can use preferred AI assistants
- Same requirements apply regardless of tool choice
- Cross-platform consistency prevents quality degradation

---

**Snapshot Status**: ‚úÖ COMPLETE - Review and compact before proceeding
**Compaction Required**: ‚ö†Ô∏è  YES - Move critical knowledge to SESSION_SUMMARY.md
**Next Command**: Review this file, then compact into SESSION_SUMMARY.md
SNAPSHOT_EOF

# Replace placeholders with actual values
sed -i.bak "s/PLATFORM_VERSION_PLACEHOLDER/${PLATFORM_VERSION}/g" "${SESSION_STATE_FILE}"
sed -i.bak "s/BRANCH_PLACEHOLDER/${CURRENT_BRANCH}/g" "${SESSION_STATE_FILE}"
sed -i.bak "s/TEST_COUNT_PLACEHOLDER/${TEST_COUNT}/g" "${SESSION_STATE_FILE}"
sed -i.bak "s/COMMITS_AHEAD_PLACEHOLDER/${COMMITS_AHEAD}/g" "${SESSION_STATE_FILE}"

# Add working directory status
if [ -z "$GIT_STATUS" ]; then
    sed -i.bak "s/WORKING_DIR_STATUS_PLACEHOLDER/Clean (no uncommitted changes)/g" "${SESSION_STATE_FILE}"
else
    CHANGE_COUNT=$(echo "$GIT_STATUS" | wc -l | tr -d ' ')
    sed -i.bak "s/WORKING_DIR_STATUS_PLACEHOLDER/${CHANGE_COUNT} uncommitted changes/g" "${SESSION_STATE_FILE}"
fi

# Add quality status
sed -i.bak "s/QUALITY_STATUS_PLACEHOLDER/Zero warnings (Ruff, Black, isort, MyPy)/g" "${SESSION_STATE_FILE}"

# Clean up backup files
rm -f "${SESSION_STATE_FILE}.bak"

echo -e "${GREEN}‚úÖ Session state snapshot created${NC}"
echo "   Location: ${SESSION_STATE_FILE}"
echo

# Display summary
echo -e "${BLUE}üìä Session State Summary${NC}"
echo -e "${BLUE}========================${NC}"
echo "   Platform: ${PLATFORM_VERSION}"
echo "   Branch: ${CURRENT_BRANCH}"
echo "   Tests: ${TEST_COUNT}"
echo "   Status: Snapshot ready for compaction"
echo

# Reminder about compaction
echo -e "${YELLOW}‚ö†Ô∏è  CRITICAL REMINDER: COMPACTION REQUIRED${NC}"
echo -e "${YELLOW}=========================================${NC}"
echo "This snapshot captures current state in detail, but MUST be compacted"
echo "into SESSION_SUMMARY.md before starting new work."
echo
echo "Compaction ensures:"
echo "   ‚Ä¢ SESSION_SUMMARY.md remains authoritative source of truth"
echo "   ‚Ä¢ Knowledge is accessible to all future sessions"
echo "   ‚Ä¢ Session history doesn't fragment across multiple files"
echo "   ‚Ä¢ New AI agents can quickly understand platform state"
echo
echo "Next steps:"
echo "   1. Review: ${SESSION_STATE_FILE}"
echo "   2. Compact: Update SESSION_SUMMARY.md with critical achievements"
echo "   3. Clean: Archive or remove old session state snapshots"
echo "   4. Verify: SESSION_SUMMARY.md reflects current state"
echo

echo -e "${GREEN}üíæ Session State Snapshot Complete!${NC}"
echo -e "${YELLOW}‚ö†Ô∏è  Remember to compact before starting new work${NC}"
echo

# Synchronize SESSION_SUMMARY.md between root and docs/monitoring
echo -e "${BLUE}üîÑ Synchronizing SESSION_SUMMARY.md locations...${NC}"
if [ -f "${SESSION_SUMMARY_ROOT}" ] && [ -f "${SESSION_SUMMARY_DOCS}" ]; then
    # Both exist - check which is newer and sync
    if [ "${SESSION_SUMMARY_ROOT}" -nt "${SESSION_SUMMARY_DOCS}" ]; then
        echo "   Root version is newer, syncing to docs/monitoring/"
        cp "${SESSION_SUMMARY_ROOT}" "${SESSION_SUMMARY_DOCS}"
    elif [ "${SESSION_SUMMARY_DOCS}" -nt "${SESSION_SUMMARY_ROOT}" ]; then
        echo "   Docs version is newer, syncing to project root"
        cp "${SESSION_SUMMARY_DOCS}" "${SESSION_SUMMARY_ROOT}"
    else
        echo "   Both locations already synchronized"
    fi
elif [ -f "${SESSION_SUMMARY_ROOT}" ]; then
    # Only root exists - copy to docs
    echo "   Copying from root to docs/monitoring/"
    cp "${SESSION_SUMMARY_ROOT}" "${SESSION_SUMMARY_DOCS}"
elif [ -f "${SESSION_SUMMARY_DOCS}" ]; then
    # Only docs exists - copy to root
    echo "   Copying from docs/monitoring/ to root"
    cp "${SESSION_SUMMARY_DOCS}" "${SESSION_SUMMARY_ROOT}"
else
    echo -e "${YELLOW}   ‚ö†Ô∏è  No SESSION_SUMMARY.md found in either location${NC}"
fi
echo -e "${GREEN}‚úÖ Synchronization complete${NC}"
echo
