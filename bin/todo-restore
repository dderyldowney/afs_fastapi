#!/bin/bash

# todo-restore: Restore development context from dual TODO system
# Usage: ./bin/todo-restore

set -euo pipefail

# Ensure we're in the project root
if [[ ! -f ".claude/DUAL_TODO_SYSTEM.md" ]]; then
    echo "Error: Must be run from AFS FastAPI project root directory"
    exit 1
fi

STRATEGIC_FILE=".claude/strategic_todos.json"
PHASE_FILE=".claude/phase_todos.json"

echo "=== AFS FastAPI Development Context Restoration ==="
echo ""

# Load and display development context for session restoration
python3 -c "
import json
import sys
from datetime import datetime, timezone

# Read strategic todos
strategic_data = {}
strategic_todos = []
try:
    with open('$STRATEGIC_FILE', 'r') as f:
        strategic_data = json.load(f)
    strategic_todos = strategic_data.get('todos', [])
except:
    print('‚ö†Ô∏è  Warning: No strategic TODO file found.')
    print('   Recommend: Use \"./bin/strategic-add\" to establish strategic objectives.')

# Read phase todos
phase_data = {}
phase_todos = []
current_phase = {}
try:
    with open('$PHASE_FILE', 'r') as f:
        phase_data = json.load(f)
    phase_todos = phase_data.get('todos', [])
    current_phase = phase_data.get('current_phase', {})
except:
    print('‚ö†Ô∏è  Warning: No phase TODO file found.')
    print('   Recommend: Use \"./bin/phase-start\" to begin development phase.')

print('üîÑ RESTORING DEVELOPMENT CONTEXT')
print('='*60)

# Platform and system status
print('Platform: AFS FastAPI Agricultural Robotics Platform')
print('TODO System: Dual-level (Strategic + Phase) management')
print('Session Type: Context restoration for continued development')
print()

# Strategic development momentum
if strategic_todos:
    strategic_pending = [t for t in strategic_todos if t['status'] == 'pending']
    strategic_completed = [t for t in strategic_todos if t['status'] == 'completed']
    strategic_progress = (len(strategic_completed) / len(strategic_todos) * 100) if strategic_todos else 0

    print('üìà STRATEGIC DEVELOPMENT MOMENTUM')
    print('-' * 40)
    print(f'Development Progress: {len(strategic_completed)}/{len(strategic_todos)} objectives ({strategic_progress:.1f}%)')

    # Show progress bar
    bar_width = 30
    completed_bars = int(strategic_progress / 100 * bar_width)
    pending_bars = bar_width - completed_bars
    progress_bar = '‚ñà' * completed_bars + '‚ñë' * pending_bars
    print(f'Progress Bar: [{progress_bar}] {strategic_progress:.1f}%')
    print()

    # Most recent strategic achievement
    if strategic_completed:
        recent_completed = sorted(strategic_completed, key=lambda x: x.get('completed_at', ''), reverse=True)
        latest = recent_completed[0]
        completed_date = latest.get('completed_at', '')[:10] if latest.get('completed_at') else 'Unknown'
        print(f'‚úÖ Latest Achievement: {latest[\"content\"]} ({completed_date})')
        print()

    # Available strategic opportunities
    if strategic_pending:
        print(f'üéØ Available Strategic Opportunities ({len(strategic_pending)} total):')

        # Prioritize high-priority items
        high_priority = [t for t in strategic_pending if t.get('priority') == 'high']
        medium_priority = [t for t in strategic_pending if t.get('priority') == 'medium']
        low_priority = [t for t in strategic_pending if t.get('priority') == 'low']

        display_count = 0
        max_display = 5

        if high_priority and display_count < max_display:
            print('   High Priority:')
            for todo in high_priority[:min(3, max_display - display_count)]:
                category = todo.get('category', 'general')
                print(f'     ‚Ä¢ {todo[\"content\"]} [{category}]')
                display_count += 1

        if medium_priority and display_count < max_display:
            remaining_slots = max_display - display_count
            print('   Medium Priority:')
            for todo in medium_priority[:min(2, remaining_slots)]:
                category = todo.get('category', 'general')
                print(f'     ‚Ä¢ {todo[\"content\"]} [{category}]')
                display_count += 1

        if len(strategic_pending) > display_count:
            print(f'     ... and {len(strategic_pending) - display_count} more objectives')
        print()
else:
    print('üìà STRATEGIC DEVELOPMENT MOMENTUM')
    print('-' * 40)
    print('No strategic objectives defined.')
    print('üîß Action Required: Use \"./bin/strategic-add\" to establish development goals.')
    print()

# Current implementation phase
print('‚öôÔ∏è  CURRENT IMPLEMENTATION PHASE')
print('-' * 40)

if current_phase.get('status') == 'active':
    phase_name = current_phase.get('name', 'Unknown Phase')
    strategic_id = current_phase.get('strategic_todo_id')
    started_at = current_phase.get('started_at', '')

    print(f'Active Phase: {phase_name}')

    # Strategic alignment context
    if strategic_id and strategic_todos:
        aligned_strategic = next((t for t in strategic_todos if t['id'] == strategic_id), None)
        if aligned_strategic:
            print(f'Strategic Context: {aligned_strategic[\"content\"]}')
        else:
            print(f'Strategic Context: {strategic_id} (objective not found)')

    # Phase timeline
    if started_at and 'T' in started_at:
        start_date = started_at[:10]
        start_time = started_at[11:16]
        current_date = datetime.now().strftime('%Y-%m-%d')
        print(f'Timeline: Started {start_date} {start_time} UTC (active {current_date})')

    print()

    if phase_todos:
        phase_pending = [t for t in phase_todos if t['status'] == 'pending']
        phase_in_progress = [t for t in phase_todos if t['status'] == 'in_progress']
        phase_completed = [t for t in phase_todos if t['status'] == 'completed']
        phase_progress = (len(phase_completed) / len(phase_todos) * 100) if phase_todos else 0

        print(f'Implementation Status: {len(phase_completed)}/{len(phase_todos)} steps ({phase_progress:.1f}%)')

        # Phase progress bar
        completed_bars = int(phase_progress / 100 * bar_width)
        pending_bars = bar_width - completed_bars
        phase_bar = '‚ñà' * completed_bars + '‚ñë' * pending_bars
        print(f'Phase Progress: [{phase_bar}] {phase_progress:.1f}%')
        print()

        # Current work state - critical for restoration
        if phase_in_progress:
            print('üîÑ WORK IN PROGRESS (Immediate Focus):')
            for step in phase_in_progress:
                time_info = f' (~{step[\"estimated_minutes\"]}min)' if 'estimated_minutes' in step else ''
                priority_marker = {'high': '[HIGH]', 'medium': '[MED]', 'low': '[LOW]'}.get(step.get('priority', 'medium'), '')
                print(f'   ‚ñ∂Ô∏è  {priority_marker} {step[\"content\"]}{time_info}')
                print(f'       ID: {step[\"id\"]} | Created: {step[\"created_at\"][:10]}')
            print()
            print('üéØ Immediate Action: Continue working on in-progress steps')
            print('   Use \"./bin/phase-complete\" when current work is finished')
            print()

        # Next steps queue
        if phase_pending:
            # Sort by priority for restoration guidance
            priority_order = {'high': 0, 'medium': 1, 'low': 2}
            next_steps = sorted(phase_pending, key=lambda x: priority_order.get(x.get('priority', 'medium'), 999))

            print(f'üìã IMPLEMENTATION QUEUE ({len(phase_pending)} pending):')
            for i, step in enumerate(next_steps[:3], 1):
                priority_marker = {'high': '[HIGH]', 'medium': '[MED]', 'low': '[LOW]'}.get(step.get('priority', 'medium'), '')
                time_info = f' (~{step[\"estimated_minutes\"]}min)' if 'estimated_minutes' in step else ''
                print(f'   {i}. {priority_marker} {step[\"content\"]}{time_info}')

            if len(next_steps) > 3:
                print(f'      ... plus {len(next_steps) - 3} additional steps')
            print()

        # Work estimates for planning
        remaining_work = phase_in_progress + phase_pending
        if remaining_work:
            total_time = sum(t.get('estimated_minutes', 30) for t in remaining_work)
            hours = total_time // 60
            minutes = total_time % 60

            print(f'üìä Work Estimates:')
            if hours > 0:
                print(f'   Remaining Time: ~{hours}h {minutes}m for {len(remaining_work)} steps')
            else:
                print(f'   Remaining Time: ~{minutes}m for {len(remaining_work)} steps')

            # Phase completion proximity
            completion_percentage = (len(phase_completed) / len(phase_todos) * 100)
            if completion_percentage >= 80:
                print(f'   Phase Status: Near completion ({completion_percentage:.1f}% complete)')
            elif completion_percentage >= 50:
                print(f'   Phase Status: Halfway point passed ({completion_percentage:.1f}% complete)')
            else:
                print(f'   Phase Status: Early implementation ({completion_percentage:.1f}% complete)')
            print()

        # Phase completion readiness
        if not phase_pending and not phase_in_progress:
            print('üéâ PHASE COMPLETION READY')
            print('   All implementation steps completed!')
            print('   Next Action: Use \"./bin/phase-end\" to archive and update strategic progress')
            print()
    else:
        print('üìã Phase started but no implementation steps defined.')
        print('üîß Action Required: Use \"./bin/phase-add\" to add TDD implementation steps')
        print()
        print('üí° TDD Methodology Pattern:')
        print('   1. Investigation steps (analyze, design)')
        print('   2. RED phase (write failing tests)')
        print('   3. GREEN phase (minimal implementation)')
        print('   4. REFACTOR phase (quality enhancement)')
        print('   5. Integration and validation')
        print('   6. Documentation')
        print()
else:
    print('No active development phase.')

    # Last completed phase context
    last_phase = current_phase.get('last_completed_phase')
    if last_phase:
        phase_name = last_phase.get('name', 'Unknown Phase')
        completed_at = last_phase.get('completed_at', '')
        final_stats = last_phase.get('final_stats', {})

        print(f'üìã Last Completed Phase: {phase_name}')
        if completed_at and 'T' in completed_at:
            completed_date = completed_at[:10]
            print(f'   Completed: {completed_date}')

        if final_stats:
            completion_pct = final_stats.get('completion_percentage', 0)
            total_steps = final_stats.get('total_steps', 0)
            completed_steps = final_stats.get('completed_steps', 0)
            print(f'   Final Status: {completed_steps}/{total_steps} steps ({completion_pct:.1f}%)')
        print()

    print('üîß Action Required: Start new development phase')
    if strategic_todos:
        pending_strategic = [t for t in strategic_todos if t['status'] == 'pending']
        if pending_strategic:
            print('   Available strategic objectives for new phase alignment')
    print('   Use \"./bin/phase-start\" to begin new development phase')
    print()

# Development workflow guidance
print('üõ†Ô∏è  DEVELOPMENT WORKFLOW GUIDANCE')
print('='*60)

# Current session priority
if current_phase.get('status') == 'active' and phase_todos:
    phase_in_progress = [t for t in phase_todos if t['status'] == 'in_progress']
    phase_pending = [t for t in phase_todos if t['status'] == 'pending']

    if phase_in_progress:
        print('üéØ SESSION PRIORITY: Complete in-progress work')
        for step in phase_in_progress:
            print(f'   Focus: {step[\"content\"]}')
        print(f'   Command: ./bin/phase-complete \"<step_description>\"')
    elif phase_pending:
        priority_next = sorted(phase_pending, key=lambda x: {'high': 0, 'medium': 1, 'low': 2}.get(x.get('priority', 'medium'), 999))
        next_step = priority_next[0]
        print('üéØ SESSION PRIORITY: Begin next implementation step')
        print(f'   Next: {next_step[\"content\"]}')
        print(f'   Command: Mark step in progress, then implement')
    else:
        print('üéØ SESSION PRIORITY: Archive completed phase')
        print(f'   Command: ./bin/phase-end')
elif strategic_todos:
    pending_strategic = [t for t in strategic_todos if t['status'] == 'pending']
    if pending_strategic:
        high_priority = [t for t in pending_strategic if t.get('priority') == 'high']
        if high_priority:
            print('üéØ SESSION PRIORITY: Start new high-priority development phase')
            print(f'   Recommend: {high_priority[0][\"content\"]}')
        else:
            print('üéØ SESSION PRIORITY: Start new development phase')
        print(f'   Command: ./bin/phase-start \"<phase_name>\"')
    else:
        print('üéØ SESSION PRIORITY: Define strategic development objectives')
        print(f'   Command: ./bin/strategic-add \"<objective>\"')
else:
    print('üéØ SESSION PRIORITY: Initialize development framework')
    print('   Command: ./bin/strategic-add \"<first_strategic_objective>\"')

print()

# Essential commands reference
print('üìö ESSENTIAL COMMANDS REFERENCE')
print('-' * 40)
print('Status and Overview:')
print('  ./bin/todo-status                       - Complete development overview')
print('  ./bin/strategic-status                  - Strategic development progress')
print('  ./bin/phase-status                      - Current phase implementation details')
print()
print('Strategic Management:')
print('  ./bin/strategic-list                    - View all strategic objectives')
print('  ./bin/strategic-add \"Objective\"         - Add new strategic objective')
print('  ./bin/strategic-complete \"Objective\"    - Mark strategic objective complete')
print()
print('Phase Management:')
print('  ./bin/phase-start \"Phase Name\"          - Start new development phase')
print('  ./bin/phase-add \"Implementation Step\"   - Add phase implementation step')
print('  ./bin/phase-complete \"Step\"             - Mark implementation step complete')
print('  ./bin/phase-end                          - Complete and archive current phase')
print()
print('Session Management:')
print('  ./bin/todo-handoff                      - Prepare context for next session')
print('  ./bin/loadsession                       - Standard session initialization')
print()

print('‚úÖ Development context restoration complete.')
print('üöÄ Ready to continue agricultural robotics platform development.')
"
# Auto-sync TODO state for session persistence
./bin/todo-sync --silent 2>/dev/null || true
