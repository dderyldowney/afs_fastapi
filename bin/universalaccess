#!/bin/bash
# Universal Access Script for AFS FastAPI Agricultural Robotics Platform
#
# Ensures ALL Claude Code agents have guaranteed access to loadsession
# and complete project context, with persistent cross-session behavior.
#
# UNIVERSAL AGENT SUPPORT:
# - Main Claude Code sessions
# - General-purpose agents
# - Specialized agents (statusline-setup, output-style-setup)
# - Subagents (Task tool spawned)
# - Cross-session persistent agents

# Color definitions for professional output
readonly BLUE='\033[0;34m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly RED='\033[1;31m'
readonly NC='\033[0m'  # No Color

# Project constants
readonly PROJECT_ROOT="$(pwd)"
readonly CLAUDE_DIR="${PROJECT_ROOT}/.claude"
readonly SESSION_MARKER="${CLAUDE_DIR}/.session_initialized"
readonly GLOBAL_SESSION="${CLAUDE_DIR}/.global_session_state"
readonly AGENT_REGISTRY="${CLAUDE_DIR}/.agent_registry.json"
readonly UNIVERSAL_MARKER="${CLAUDE_DIR}/.universal_access_enabled"
readonly LOADSESSION_SCRIPT="${PROJECT_ROOT}/bin/run_loadsession.sh"

# Agent identification
readonly AGENT_ID="${CLAUDE_AGENT_ID:-agent_$(openssl rand -hex 4)_$(date +%s)}"
readonly TIMESTAMP=$(date +%s)

echo -e "${BLUE}üåê AFS FastAPI Universal Agent Access${NC}"
echo -e "${BLUE}====================================${NC}"
echo ""

# Function to verify loadsession availability
verify_loadsession_access() {
    echo -e "${BLUE}üîç Verifying loadsession access...${NC}"

    if [[ ! -f "${LOADSESSION_SCRIPT}" ]]; then
        echo -e "${RED}‚ùå loadsession script not found at ${LOADSESSION_SCRIPT}${NC}"
        return 1
    fi

    if [[ ! -x "${LOADSESSION_SCRIPT}" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Making loadsession executable...${NC}"
        chmod +x "${LOADSESSION_SCRIPT}"
    fi

    echo -e "${GREEN}‚úÖ loadsession script accessible${NC}"
    return 0
}

# Function to check universal access markers
check_universal_access() {
    echo -e "${BLUE}üîç Checking universal access markers...${NC}"

    local access_confirmed=true

    # Check session marker
    if [[ ! -f "${SESSION_MARKER}" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Session marker missing${NC}"
        access_confirmed=false
    fi

    # Check global session state
    if [[ ! -f "${GLOBAL_SESSION}" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Global session state missing${NC}"
        access_confirmed=false
    fi

    # Check universal access marker
    if [[ ! -f "${UNIVERSAL_MARKER}" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Universal access marker missing${NC}"
        access_confirmed=false
    fi

    if $access_confirmed; then
        echo -e "${GREEN}‚úÖ All access markers present${NC}"
        return 0
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Some access markers missing - will initialize${NC}"
        return 1
    fi
}

# Function to register agent in registry
register_agent() {
    echo -e "${BLUE}üìù Registering agent ${AGENT_ID:0:12}...${NC}"

    # Ensure .claude directory exists
    mkdir -p "${CLAUDE_DIR}"

    # Initialize or load existing registry
    local registry_content="{}"
    if [[ -f "${AGENT_REGISTRY}" ]]; then
        registry_content=$(cat "${AGENT_REGISTRY}")
    fi

    # Add current agent to registry
    local updated_registry
    updated_registry=$(echo "${registry_content}" | jq --arg agent_id "${AGENT_ID}" \
        --arg timestamp "${TIMESTAMP}" \
        --arg project_root "${PROJECT_ROOT}" \
        '.[$agent_id] = {
            "initialized_at": ($timestamp | tonumber),
            "project_root": $project_root,
            "loadsession_executed": true
        }')

    # Save updated registry
    echo "${updated_registry}" > "${AGENT_REGISTRY}"
    echo -e "${GREEN}‚úÖ Agent registered successfully${NC}"
}

# Function to create universal access markers
create_access_markers() {
    echo -e "${BLUE}üéØ Creating universal access markers...${NC}"

    # Ensure .claude directory exists
    mkdir -p "${CLAUDE_DIR}"

    # Create session marker
    touch "${SESSION_MARKER}"
    echo -e "${GREEN}‚úÖ Session marker created${NC}"

    # Create global session state
    touch "${GLOBAL_SESSION}"
    echo -e "${GREEN}‚úÖ Global session state created${NC}"

    # Create universal access marker
    touch "${UNIVERSAL_MARKER}"
    echo -e "${GREEN}‚úÖ Universal access marker created${NC}"
}

# Function to execute loadsession with agent context
execute_loadsession() {
    echo -e "${BLUE}üöÄ Executing loadsession with agent context...${NC}"

    # Set agent environment
    export CLAUDE_AGENT_ID="${AGENT_ID}"

    # Execute loadsession
    if "${LOADSESSION_SCRIPT}"; then
        echo -e "${GREEN}‚úÖ loadsession executed successfully${NC}"
        echo -e "${GREEN}ü§ñ Agent ${AGENT_ID:0:12} has full context access${NC}"
        return 0
    else
        echo -e "${RED}‚ùå loadsession execution failed${NC}"
        return 1
    fi
}

# Function to verify context availability
verify_context_access() {
    echo -e "${BLUE}üîç Verifying project context access...${NC}"

    # Check SESSION_SUMMARY.md availability
    if [[ -f "${PROJECT_ROOT}/SESSION_SUMMARY.md" ]]; then
        echo -e "${GREEN}‚úÖ SESSION_SUMMARY.md accessible${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  SESSION_SUMMARY.md not found${NC}"
    fi

    # Check key documentation
    local docs_count=0
    local doc_files=("WORKFLOW.md" "TDD_WORKFLOW.md" "SYNCHRONIZATION_INFRASTRUCTURE.md")

    for doc in "${doc_files[@]}"; do
        if [[ -f "${PROJECT_ROOT}/${doc}" ]]; then
            ((docs_count++))
        fi
    done

    echo -e "${GREEN}‚úÖ ${docs_count}/${#doc_files[@]} key documentation files accessible${NC}"

    # Check agent registry status
    if [[ -f "${AGENT_REGISTRY}" ]]; then
        local agent_count
        agent_count=$(jq 'length' "${AGENT_REGISTRY}")
        echo -e "${GREEN}‚úÖ Agent registry active with ${agent_count} registered agents${NC}"
    fi
}

# Main execution flow
main() {
    echo -e "${BLUE}üéØ Agent ID: ${AGENT_ID:0:12}${NC}"
    echo -e "${BLUE}üìÅ Project Root: ${PROJECT_ROOT}${NC}"
    echo ""

    # Step 1: Verify loadsession access
    if ! verify_loadsession_access; then
        echo -e "${RED}‚ùå Cannot proceed without loadsession access${NC}"
        exit 1
    fi

    # Step 2: Check existing universal access
    local needs_initialization=false
    if ! check_universal_access; then
        needs_initialization=true
    fi

    # Step 3: Initialize if needed
    if $needs_initialization; then
        echo ""
        echo -e "${YELLOW}üîÑ Initializing universal access for agent...${NC}"

        create_access_markers
        register_agent

        if execute_loadsession; then
            echo ""
            echo -e "${GREEN}üéâ Universal access initialization complete!${NC}"
        else
            echo -e "${RED}‚ùå Initialization failed${NC}"
            exit 1
        fi
    else
        echo ""
        echo -e "${GREEN}‚úÖ Universal access already configured${NC}"
        register_agent  # Register this agent even if already initialized
    fi

    # Step 4: Verify context access
    echo ""
    verify_context_access

    echo ""
    echo -e "${GREEN}üåê Universal Agent Access Complete${NC}"
    echo -e "${GREEN}‚ú® Agent ${AGENT_ID:0:12} ready for sophisticated agricultural robotics development${NC}"
}

# Execute main function
main "$@"