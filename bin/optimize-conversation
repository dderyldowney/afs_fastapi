#!/usr/bin/env python3
"""
Real-time conversation optimization tool for AFS FastAPI.

Demonstrates and tests the project-wide token optimization system
with actual conversation processing and live metrics.
"""

import argparse
import json
import sys
from pathlib import Path

# Add project to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from afs_fastapi.core.conversation_manager import (  # noqa: E402
    configure_optimization,
    get_conversation_manager,
    get_optimization_status,
    optimize_interaction,
)


def main():
    """Main conversation optimization tool."""
    parser = argparse.ArgumentParser(
        description="Real-time conversation optimization for AFS FastAPI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Interactive optimization session
  ./bin/optimize-conversation --interactive

  # Optimize specific input/output
  ./bin/optimize-conversation --input "Help implement tractor coordination" --output "Implementation details..."

  # Show optimization status
  ./bin/optimize-conversation --status

  # Configure optimization settings
  ./bin/optimize-conversation --configure --token-budget 1500 --adaptive

  # Test optimization with sample conversations
  ./bin/optimize-conversation --test-sample
        """,
    )

    # Operation modes
    parser.add_argument(
        "--interactive", action="store_true", help="Start interactive optimization session"
    )
    parser.add_argument(
        "--test-sample", action="store_true", help="Test with sample agricultural conversations"
    )
    parser.add_argument("--status", action="store_true", help="Show current optimization status")
    parser.add_argument("--configure", action="store_true", help="Configure optimization settings")

    # Content processing
    parser.add_argument("--input", type=str, help="User input to optimize")
    parser.add_argument("--output", type=str, help="AI response to optimize")
    parser.add_argument(
        "--command-type",
        type=str,
        default="general",
        choices=["general", "git", "test", "status", "safety", "agricultural"],
        help="Type of interaction for optimization tuning",
    )

    # Configuration options
    parser.add_argument("--token-budget", type=int, help="Set token budget per conversation turn")
    parser.add_argument("--adaptive", action="store_true", help="Enable adaptive optimization mode")
    parser.add_argument(
        "--no-adaptive", action="store_true", help="Disable adaptive optimization mode"
    )
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    parser.add_argument("--disable", action="store_true", help="Disable optimization system")
    parser.add_argument("--enable", action="store_true", help="Enable optimization system")

    # Output options
    parser.add_argument("--json", action="store_true", help="Output results in JSON format")
    parser.add_argument(
        "--verbose", action="store_true", help="Show detailed optimization information"
    )

    args = parser.parse_args()

    # Handle configuration
    if args.configure:
        configure_optimization_settings(args)
        return

    # Handle status display
    if args.status:
        show_optimization_status(args.json, args.verbose)
        return

    # Handle interactive mode
    if args.interactive:
        run_interactive_session()
        return

    # Handle sample testing
    if args.test_sample:
        run_sample_tests(args.json, args.verbose)
        return

    # Handle single input/output optimization
    if args.input:
        optimize_single_interaction(args)
        return

    # Default: show help
    parser.print_help()


def configure_optimization_settings(args):
    """Configure optimization system settings."""
    print("🔧 Configuring AFS FastAPI Token Optimization...")

    config_changes = []

    if args.enable:
        configure_optimization(enabled=True)
        config_changes.append("Optimization: ENABLED")
    elif args.disable:
        configure_optimization(enabled=False)
        config_changes.append("Optimization: DISABLED")

    if args.token_budget:
        configure_optimization(token_budget=args.token_budget)
        config_changes.append(f"Token Budget: {args.token_budget} per turn")

    if args.adaptive:
        configure_optimization(adaptive_mode=True)
        config_changes.append("Adaptive Mode: ENABLED")
    elif args.no_adaptive:
        configure_optimization(adaptive_mode=False)
        config_changes.append("Adaptive Mode: DISABLED")

    if args.debug:
        configure_optimization(debug_mode=True)
        config_changes.append("Debug Mode: ENABLED")

    if config_changes:
        print("\nConfiguration updated:")
        for change in config_changes:
            print(f"  ✓ {change}")
    else:
        print("No configuration changes specified.")

    print("\nCurrent configuration:")
    status = get_optimization_status()
    config = status.get("configuration", {})
    print(f"  Optimization enabled: {status.get('optimization_enabled', False)}")
    print(f"  Token budget per turn: {config.get('token_budget_per_turn', 'unknown')}")
    print(f"  Adaptive mode: {config.get('adaptive_mode', False)}")
    print(f"  Debug mode: {config.get('debug_mode', False)}")


def show_optimization_status(json_output=False, verbose=False):
    """Show current optimization status."""
    status = get_optimization_status()

    if json_output:
        print(json.dumps(status, indent=2))
        return

    print("📊 AFS FastAPI Token Optimization Status")
    print("=" * 45)

    # Basic status
    enabled = status.get("optimization_enabled", False)
    print(f"Optimization: {'🟢 ENABLED' if enabled else '🔴 DISABLED'}")

    # Global metrics
    total_interactions = status.get("total_interactions", 0)
    total_saved = status.get("total_tokens_saved", 0)
    active_conversations = status.get("active_conversations", 0)

    print(f"Total interactions: {total_interactions}")
    print(f"Total tokens saved: {total_saved}")
    print(f"Active conversations: {active_conversations}")

    # Configuration
    config = status.get("configuration", {})
    print(f"Token budget per turn: {config.get('token_budget_per_turn', 'N/A')}")
    print(f"Adaptive mode: {'Yes' if config.get('adaptive_mode', False) else 'No'}")

    # Platform summary
    platform = status.get("platform_summary", {})
    if platform:
        print("\nSession Summary:")
        session_duration = platform.get("session_duration_minutes", 0)
        print(f"  Session duration: {session_duration:.1f} minutes")

        total_metrics = platform.get("total_metrics", {})
        turns = total_metrics.get("turns", 0)
        avg_reduction = total_metrics.get("average_reduction_percent", 0)
        agricultural_turns = total_metrics.get("agricultural_turns", 0)
        safety_turns = total_metrics.get("safety_critical_turns", 0)

        print(f"  Conversation turns: {turns}")
        print(f"  Average reduction: {avg_reduction:.1f}%")
        print(f"  Agricultural focus: {agricultural_turns} turns")
        print(f"  Safety-critical: {safety_turns} turns")

    if verbose and "conversation_list" in status:
        conversations = status["conversation_list"]
        if conversations:
            print(f"\nActive conversations: {', '.join(conversations)}")


def run_interactive_session():
    """Run interactive optimization session."""
    print("🤖 AFS FastAPI Interactive Token Optimization Session")
    print("=" * 55)
    print("Enter conversations to see real-time optimization.")
    print("Commands: /status, /config, /export, /reset, /quit")
    print()

    manager = get_conversation_manager()
    conversation_id = "interactive_session"

    while True:
        try:
            # Get user input
            user_input = input("User: ").strip()

            if not user_input:
                continue

            # Handle commands
            if user_input.startswith("/"):
                handle_interactive_command(user_input, manager, conversation_id)
                continue

            # Simulate AI response (in real use, this would come from actual AI)
            ai_response = generate_sample_ai_response(user_input)

            # Process through optimization
            result = manager.process_conversation_turn(
                user_input=user_input, ai_response=ai_response, conversation_id=conversation_id
            )

            # Display results
            optimized_content = result["optimized_content"]
            optimization_meta = result["optimization_metadata"]

            print(f"\nOptimized Input: {optimized_content['user_input']}")
            print(f"AI Response: {optimized_content['ai_response']}")

            # Show optimization metrics
            total_saved = optimization_meta["total_tokens_saved"]
            input_meta = optimization_meta["input"]
            response_meta = optimization_meta["response"]

            if total_saved > 0:
                print(f"💰 Tokens saved: {total_saved}")
                if input_meta.get("tokens_saved", 0) > 0:
                    print(f"   Input: {input_meta['tokens_saved']} tokens saved")
                if response_meta.get("tokens_saved", 0) > 0:
                    print(f"   Response: {response_meta['tokens_saved']} tokens saved")

            # Show agricultural compliance
            compliance = result["agricultural_compliance"]
            if compliance["agricultural_keywords_detected"]:
                keywords = ", ".join(compliance["agricultural_keywords_detected"])
                print(f"🚜 Agricultural keywords: {keywords}")
            if compliance["safety_critical"]:
                print("⚠️  Safety-critical content detected")

            print()

        except KeyboardInterrupt:
            print("\n\n👋 Optimization session ended.")
            break
        except EOFError:
            break


def handle_interactive_command(command, manager, conversation_id):
    """Handle interactive session commands."""
    if command == "/quit":
        print("👋 Goodbye!")
        sys.exit(0)

    elif command == "/status":
        metrics = manager.get_conversation_metrics(conversation_id)
        session = metrics.get("session_summary", {})
        total_metrics = session.get("total_metrics", {})

        print("\nSession Status:")
        print(f"  Turns: {total_metrics.get('turns', 0)}")
        print(f"  Tokens saved: {total_metrics.get('tokens_saved', 0)}")
        print(f"  Average reduction: {total_metrics.get('average_reduction_percent', 0):.1f}%")
        print()

    elif command == "/config":
        status = get_optimization_status()
        config = status.get("configuration", {})
        print("\nCurrent Configuration:")
        print(f"  Optimization: {'ON' if status.get('optimization_enabled', False) else 'OFF'}")
        print(f"  Token budget: {config.get('token_budget_per_turn', 'N/A')}")
        print(f"  Adaptive mode: {'ON' if config.get('adaptive_mode', False) else 'OFF'}")
        print()

    elif command == "/export":
        files = manager.export_conversation_data(conversation_id)
        if files:
            print(f"\n📁 Exported to: {files[0]}")
        print()

    elif command == "/reset":
        manager.reset_conversation(conversation_id)
        print("\n🔄 Conversation reset. Final metrics exported.")
        print()

    else:
        print(f"\nUnknown command: {command}")
        print("Available: /status, /config, /export, /reset, /quit")
        print()


def generate_sample_ai_response(user_input):
    """Generate sample AI response based on input content."""
    input_lower = user_input.lower()

    if any(word in input_lower for word in ["tractor", "agricultural", "farming", "field"]):
        return (
            "I'll help you implement the agricultural equipment coordination system. "
            "This involves ISO 11783 compliance, safety protocols, and fleet management. "
            "Let me start with the basic tractor communication interface..."
        )

    elif any(word in input_lower for word in ["safety", "emergency", "critical", "stop"]):
        return (
            "Safety is paramount in agricultural operations. Emergency stop procedures "
            "must be implemented according to ISO standards with immediate equipment "
            "shutdown capabilities and collision avoidance systems."
        )

    elif any(word in input_lower for word in ["git", "status", "commit", "branch"]):
        return (
            "Current git status shows modifications in the agricultural equipment modules. "
            "Recent commits include safety enhancements and ISO compliance updates. "
            "The main branch is stable for production deployment."
        )

    elif any(word in input_lower for word in ["test", "pytest", "unittest"]):
        return (
            "Running comprehensive test suite for agricultural robotics platform. "
            "This includes unit tests for equipment interfaces, integration tests "
            "for fleet coordination, and compliance validation tests."
        )

    else:
        return (
            "I understand your request. Let me provide a comprehensive solution "
            "that addresses your needs while maintaining agricultural safety standards "
            "and following best practices for the AFS FastAPI platform."
        )


def optimize_single_interaction(args):
    """Optimize a single input/output pair."""
    result = optimize_interaction(
        user_input=args.input, ai_response=args.output or "", command_type=args.command_type
    )

    if args.json:
        print(json.dumps(result, indent=2))
        return

    # Display optimization results
    optimized_content = result["optimized_content"]
    optimization_meta = result["optimization_metadata"]

    print("🔧 Token Optimization Results")
    print("=" * 35)

    print(f"\nOriginal Input: {result['original_content']['user_input']}")
    print(f"Optimized Input: {optimized_content['user_input']}")

    if result["original_content"]["ai_response"]:
        print(f"\nOriginal Response: {result['original_content']['ai_response']}")
        print(f"Optimized Response: {optimized_content['ai_response']}")

    # Show savings
    total_saved = optimization_meta["total_tokens_saved"]
    print(f"\n💰 Total tokens saved: {total_saved}")

    input_meta = optimization_meta["input"]
    if input_meta.get("optimization_applied", False):
        input_saved = input_meta.get("tokens_saved", 0)
        input_reduction = input_meta.get("reduction_percentage", 0)
        print(f"   Input optimization: {input_saved} tokens ({input_reduction:.1f}% reduction)")

    response_meta = optimization_meta["response"]
    if response_meta.get("optimization_applied", False):
        response_saved = response_meta.get("tokens_saved", 0)
        response_reduction = response_meta.get("reduction_percentage", 0)
        print(
            f"   Response optimization: {response_saved} tokens ({response_reduction:.1f}% reduction)"
        )

    # Show agricultural compliance
    compliance = result["agricultural_compliance"]
    if compliance["agricultural_keywords_detected"]:
        keywords = ", ".join(compliance["agricultural_keywords_detected"])
        print(f"\n🚜 Agricultural keywords preserved: {keywords}")

    if compliance["safety_critical"]:
        print("⚠️  Safety-critical content detected and preserved")


def run_sample_tests(json_output=False, verbose=False):
    """Run sample optimization tests with various conversation types."""
    print("🧪 Running Sample Token Optimization Tests")
    print("=" * 45)

    # Test scenarios
    test_scenarios = [
        {
            "name": "Agricultural Equipment Query",
            "input": "How do I implement multi-tractor coordination with ISO 11783 compliance for field operations?",
            "response": "To implement multi-tractor coordination with ISO 11783 compliance, you'll need to establish ISOBUS communication protocols, implement safety monitoring systems, configure fleet management interfaces, and ensure emergency stop procedures are in place according to agricultural safety standards.",
            "type": "agricultural",
        },
        {
            "name": "Safety Emergency Procedure",
            "input": "What are the emergency stop procedures for agricultural equipment malfunction?",
            "response": "Emergency stop procedures must immediately halt all equipment operations, activate visual and audible alarms, engage mechanical brakes, shutdown power systems, and notify operators. Critical safety protocols require ISO compliance validation and automatic collision avoidance system activation.",
            "type": "safety",
        },
        {
            "name": "Development Status Check",
            "input": "Show me the current git status and recent commits for the project",
            "response": "Current git status shows 3 modified files in the agricultural equipment modules. Recent commits include safety enhancements, ISO compliance updates, and fleet coordination improvements. The main branch is stable.",
            "type": "git",
        },
        {
            "name": "Test Execution",
            "input": "Run the test suite and show me the results",
            "response": "Executing comprehensive test suite: 214 tests total, 211 passing, 3 expected failures. Agricultural equipment tests passed, safety protocol validation successful, ISO compliance verified. Test coverage at 96%.",
            "type": "test",
        },
        {
            "name": "General Development",
            "input": "Help me refactor the equipment monitoring module",
            "response": "I'll help refactor the equipment monitoring module. This involves extracting common interfaces, implementing observer patterns for real-time updates, optimizing data structures for performance, and maintaining backward compatibility with existing systems.",
            "type": "general",
        },
    ]

    results = []
    total_original_tokens = 0
    total_optimized_tokens = 0

    for scenario in test_scenarios:
        print(f"\nTesting: {scenario['name']}")

        result = optimize_interaction(
            user_input=scenario["input"],
            ai_response=scenario["response"],
            command_type=scenario["type"],
        )

        # Calculate metrics
        optimization_meta = result["optimization_metadata"]
        tokens_saved = optimization_meta["total_tokens_saved"]

        # Estimate original vs optimized tokens
        original_content = result["original_content"]
        optimized_content = result["optimized_content"]

        original_tokens = len(original_content["user_input"] + original_content["ai_response"]) // 4
        optimized_tokens = (
            len(optimized_content["user_input"] + optimized_content["ai_response"]) // 4
        )

        total_original_tokens += original_tokens
        total_optimized_tokens += optimized_tokens

        reduction_percent = (
            ((original_tokens - optimized_tokens) / original_tokens * 100)
            if original_tokens > 0
            else 0
        )

        print(
            f"  Tokens: {original_tokens} → {optimized_tokens} ({reduction_percent:.1f}% reduction)"
        )

        # Show agricultural compliance
        compliance = result["agricultural_compliance"]
        if compliance["agricultural_keywords_detected"]:
            keywords = ", ".join(compliance["agricultural_keywords_detected"])
            print(f"  🚜 Agricultural: {keywords}")
        if compliance["safety_critical"]:
            print("  ⚠️  Safety-critical content preserved")

        results.append(
            {
                "scenario": scenario["name"],
                "original_tokens": original_tokens,
                "optimized_tokens": optimized_tokens,
                "tokens_saved": tokens_saved,
                "reduction_percent": reduction_percent,
                "agricultural_keywords": compliance["agricultural_keywords_detected"],
                "safety_critical": compliance["safety_critical"],
            }
        )

    # Summary
    overall_reduction = (
        ((total_original_tokens - total_optimized_tokens) / total_original_tokens * 100)
        if total_original_tokens > 0
        else 0
    )

    print("\n📊 Test Summary")
    print("=" * 20)
    print(f"Total scenarios: {len(test_scenarios)}")
    print(f"Original tokens: {total_original_tokens}")
    print(f"Optimized tokens: {total_optimized_tokens}")
    print(f"Overall reduction: {overall_reduction:.1f}%")

    # Agricultural and safety analysis
    agricultural_scenarios = [r for r in results if r["agricultural_keywords"]]
    safety_scenarios = [r for r in results if r["safety_critical"]]

    print(f"Agricultural scenarios: {len(agricultural_scenarios)}")
    print(f"Safety-critical scenarios: {len(safety_scenarios)}")

    if json_output:
        print("\nDetailed Results:")
        print(json.dumps(results, indent=2))


if __name__ == "__main__":  # type: ignore
    main()
