#!/bin/bash

set -euo pipefail

PROJECT_ROOT=$(git rev-parse --show-toplevel)
cd "$PROJECT_ROOT"

# pytest-xdist configuration:
# -n auto: Use all available CPU cores for parallel execution
# --dist loadfile: Distribute tests by file (ensures all tests in same file run on same worker)
#   This is critical for singleton-based tests (e.g., TokenUsageLogger) that require
#   module-level initialization to happen once per worker without race conditions.
#   loadfile is more aggressive than loadscope and ensures file-level isolation.
PYTEST_ARGS="-v --tb=short -n auto --dist loadfile"
TIMEOUT=60
COVERAGE=false
SERIAL=false
PATHS=()

print_usage() {
    echo "Usage: $(basename "$0") [-h] [-q] [-c] [-s] [-t TIMEOUT] [PATHS...]"
    echo "  -h, --help      Show this help message and exit."
    echo "  -q, --quiet     Run pytest in quiet mode."
    echo "  -c, --coverage  Generate a coverage report."
    echo "  -s, --serial    Run tests serially (disable parallelization)."

}

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            print_usage
            exit 0
            ;;
        -q|--quiet)
            PYTEST_ARGS="${PYTEST_ARGS//-v/}"
            PYTEST_ARGS+=" -q"
            shift
            ;;
        -c|--coverage)
            COVERAGE=true
            shift
            ;;
        -s|--serial)
            SERIAL=true
            shift
            ;;

        *)
            PATHS+=("$1")
            shift
            ;;
    esac
done

FINAL_CMD="pytest $PYTEST_ARGS"

if [ "$SERIAL" = true ]; then
    FINAL_CMD="${FINAL_CMD// -n auto/}"  # Remove parallelization for serial mode
fi

if [ "$COVERAGE" = true ]; then
    FINAL_CMD+=" --cov=afs_fastapi --cov-report=html"
fi

if [ ${#PATHS[@]} -gt 0 ]; then
    FINAL_CMD+=" ${PATHS[*]}"
fi

echo "ðŸš€ Running tests: $FINAL_CMD"
eval "$FINAL_CMD"
